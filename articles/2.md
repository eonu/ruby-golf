<p align="center"><img width="100" src="../assets/golf.png"></p>

# Methods, blocks and lambdas

*The different ways in which executable code can be stored and called, and which way is best for code-golf.*

------

- [Methods](#methods)
- [Blocks, lambdas (and procs?)](#blocks,_lambdas_(and_procs?))

---

## Methods <a name="methods"></a>

In the previous article, methods were the type of procedure used to execute code. In all object-oriented programming languages, methods are undeniably the most popular way of executing code. However, Ruby offers another alternative to methods, that is **blocks**.

Despite *block* sounding like a very general term, they are a significantly different feature to methods, despite the fact that both of them do store what most people would call blocks of code.

In code-golf, **your solution should never be in the form of a method**. Lambdas save quite a number of bytes over methods, as you will see below.

## Blocks, lambdas (and procs?) <a name="blocks,_lambdas_(and_procs?)"></a>

Blocks are denoted by a section of code enclosed within `{ ... }` or `do ... end`, where `â€¦` represents the code. In code-golf, you'll almost always want to use `{ ... }` because it saves bytes. However, note that `{ .. }` does have higher precedence than `do ... end`.

Note that blocks mean nothing when used as a standalone, like `{puts 'Block!'}`. And as such, it wouldn't make sense to directly assign a block to a variable:

```ruby
block = {puts 'Block!'}

#=> syntax error, unexpected tSTRING_BEG, expecting keyword_do or '{' or '('
#=> block = {puts 'Block!'}
#=>                 ^
#=> syntax error, unexpected '}', expecting end-of-input
```

Blocks can only be passed into methods, and can also have parameters (as seen with the `map` example below):

```ruby
3.times {print '3'} #=> 333
[1,2,3].map {|x| x**2} #=> [1,4,9]
```

What if we need to store blocks? This is where lambdas and procs come in.

[Procs and lambdas do have their differences](http://awaxman11.github.io/blog/2013/08/05/what-is-the-difference-between-a-block/), but most of the time you can use either without any trouble. However, generally lambdas are more useful in code-golf for one reason. You guessed it, bytes!

```ruby
# 40 bytes
a = Proc.new {puts "This is code-golf!"}

# 38 bytes
b = lambda {puts "This is code-golf!"}
```

So we saved two bytes, but it gets better. There is an alternative way of declaring a lambda, known as the *stab* operator, or the *stabby lambda*, denoted by `->`. Note that parameters in the stabby lambda are defined outside of the `{}`. The parentheses are optional though. And you can also define lambdas without parameters:

```ruby
c = ->(param){puts param}
d = ->param{puts param}
e = ->{puts 'Hello!'}
```

Lambdas and procs can be called in three different ways. Now if we fully golf everything by removing whitespace:

```ruby
a=Proc.new{|s|print s}
b=lambda{|s|print s}
c=->s{print s}

a['Hello!']; a.('Hello!'); a.call('Hello!') #=> Hello!Hello!Hello!
b['Hello!']; b.('Hello!'); b.call('Hello!') #=> Hello!Hello!Hello!
c['Hello!']; c.('Hello!'); c.call('Hello!') #=> Hello!Hello!Hello!
```

The `[]` notation is a bit ambiguous since arrays use the same operator to access elements, but disambiguity is not a goal in code-golf! Use `[]` because it costs one less byte than `.()`.

This example demonstrates how storing blocks in stabby lambdas can save a few bytes:

```ruby
# 34 bytes
a=->x{print b=x*3,$/,x+' '+x,$/,b}

# 41 bytes
def b x
  print a=x*3,$/,x+' '+x,$/,a
end

# Lambda call
a['@']

#=> @@@
#=> @ @
#=> @@@

# Method call
b'@'

#=> @@@
#=> @ @
#=> @@@
```

However, do note that actually calling the lambda does add two more bytes thanks to having to call with `[]`.

---

|      Previous article       |              Next article               |
| :-------------------------: | :-------------------------------------: |
| [General](../articles/1.md) | [IO, Kernel and ARGV](../articles/3.md) |

